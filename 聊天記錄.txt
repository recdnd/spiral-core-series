1
1.1
1.2
1.2.7
寫
parents 在你实现里是怎么打印的（字段名/格式）。
1
生成 observe 的代碼
spiral_core_v045_frontier-recent-k-fix.pyLines 136-142
        heat, top = conflict_heat(h,WIN)        key,_heat,dom,domc=top        sig=sig_no_dom(WIN,heat,top)        if sig!=last_obs_sig:            h.add(mk_observe(clk,[e.id],f"observe=conflict_heat; win={WIN}; total_heat={heat}; top={key}:{heat}:{dom}:{domc}"))            last_obs_sig=sig
生成 noise 的代碼
spiral_core_v045_frontier-recent-k-fix.pyLines 144-148
 
        if heat>=2 and (h.events[-1].ts-last_conflict_ts)>=COOLDOWN_MS:            obs=next((x for x in reversed(h.events) if x.meta.get("kind")=="observe"), None)            parents=[e.id]+([obs.id] if obs else [])            h.add(mk_noise(clk,parents,f"NOISE:{rnd_id()}:conflict(2):top={key}:{heat}:{dom}:{domc}:{lab}; topic={t}"))            last_conflict_ts=h.events[-1].ts
相關輔助函數
spiral_core_v045_frontier-recent-k-fix.pyLines 48-50
def mk_observe(clk,parents,payload):    ts=clk.tick()    return Event(ts,rnd_id(),parents,{"kind":"observe","observe":"conflict_heat"},payload)
spiral_core_v045_frontier-recent-k-fix.pyLines 44-46
def mk_noise(clk,parents,payload):    ts=clk.tick()    return Event(ts,rnd_id(),parents,{"kind":"noise","noise_kind":"conflict(2)"},payload)
conflict_heat 函数的完整实现：
spiral_core_v045_frontier-recent-k-fix.pyLines 52-60
def conflict_heat(h,win=14):    inp=[e for e in h.events if e.meta.get("kind")=="input"]    tail=inp[-win:]    topics=[e.meta.get("topic","?") for e in tail]    heat=sum(1 for i in range(1,len(topics)) if topics[i]!=topics[i-1])    counts={}    for t in topics: counts[t]=counts.get(t,0)+1    dom=max(counts.items(), key=lambda kv: kv[1])[0] if counts else "?"    return heat, ("topic",heat,dom,counts.get(dom,0))
打印 parents 的最小 patch
把 “parents=冲突对”作为 invariant 自动检查项
# spiral_core_v045_frontier-recent-k-fix.py  (<200 lines)
import time, random, hashlib, math
from dataclasses import dataclass, field
from typing import List, Dict, Any, Set

def now_ms(): return int(time.time()*1000)
def h16(s): return hashlib.sha1(s.encode()).hexdigest()[:16]
def rnd_id(): return h16(str(random.random())+str(now_ms()))

class Clock:
    def __init__(self): self.t = now_ms()
    def tick(self, step=1):
        cur = now_ms()
        self.t = max(self.t + step, cur)
        return self.t

@dataclass
class Event:
    ts:int; id:str; parent_ids:List[str]
    meta:Dict[str,Any]=field(default_factory=dict)
    payload:str=""

@dataclass
class History:
    events:List[Event]=field(default_factory=list)
    by_id:Dict[str,Event]=field(default_factory=dict)
    def add(self,e): self.events.append(e); self.by_id[e.id]=e

def fmt_score(x): return f"{x:.3e}" if x < 1e-2 else f"{x:.3f}"
def last_id(h): return h.events[-1].id if h.events else None

def trace_score(e,h,half_life_ms=450):
    age = max(0, h.events[-1].ts - e.ts)
    return math.exp(-age/max(1,half_life_ms))

def mk_input(clk,h,topic,label):
    ts=clk.tick(); pid=last_id(h)
    return Event(ts,rnd_id(),[pid] if pid else [],{"kind":"input","topic":topic},f"{label}; topic={topic}")

def mk_repair(clk,h,topic):
    ts=clk.tick(); pid=last_id(h)
    return Event(ts,rnd_id(),[pid] if pid else [],{"kind":"input","topic":topic},f"repair: summarize; topic={topic}")

def mk_noise(clk,parents,payload):
    ts=clk.tick()
    return Event(ts,rnd_id(),parents,{"kind":"noise","noise_kind":"conflict(2)"},payload)

def mk_observe(clk,parents,payload):
    ts=clk.tick()
    return Event(ts,rnd_id(),parents,{"kind":"observe","observe":"conflict_heat"},payload)

def conflict_heat(h,win=14):
    inp=[e for e in h.events if e.meta.get("kind")=="input"]
    tail=inp[-win:]
    topics=[e.meta.get("topic","?") for e in tail]
    heat=sum(1 for i in range(1,len(topics)) if topics[i]!=topics[i-1])
    counts={}
    for t in topics: counts[t]=counts.get(t,0)+1
    dom=max(counts.items(), key=lambda kv: kv[1])[0] if counts else "?"
    domc=counts.get(dom,0)
    
    # pair_ids: 绑定"冲突"的两条输入（默认取 dominant topic 的最后两条）
    dom_tail=[e.id for e in tail if e.meta.get("topic","?")==dom]
    pair_ids=dom_tail[-2:]
    
    # 保底：不足 2 个就用窗口内最近 input 补齐（去重）
    if len(pair_ids)<2:
        for e in reversed(tail):
            if e.id not in pair_ids:
                pair_ids.append(e.id)
            if len(pair_ids)==2:
                break
    
    # 统一顺序：旧->新（因为上面可能 append）
    if len(pair_ids)==2 and pair_ids[0]==tail[-1].id:
        pair_ids=pair_ids[::-1]
    
    return heat, ("topic",heat,dom,domc), pair_ids

def sig_no_dom(win,total_heat,top):
    key,heat,dom,_=top
    return f"win={win};total_heat={total_heat};top={key}:{heat}:{dom}"

def invariant_conflict_parents(h):
    by_id = {e.id: e for e in h.events}
    errs = []

    def kind(e):
        return e.meta.get("kind", "?")

    # 1) observe 必须绑定到 input
    for e in h.events:
        if e.meta.get("kind") == "observe" and e.meta.get("observe") == "conflict_heat":
            if len(e.parent_ids) != 1:
                errs.append(f"OBS parents len != 1: obs={e.id[:8]} p={len(e.parent_ids)}")
                continue
            pid = e.parent_ids[0]
            pe = by_id.get(pid)
            if pe is None:
                errs.append(f"OBS parent missing: obs={e.id[:8]} parent={pid[:8]}")
            elif kind(pe) != "input":
                errs.append(f"OBS parent not input: obs={e.id[:8]} parent={pid[:8]} kind={kind(pe)}")

    # 2) noise(conflict(2)) 必须是 [input, observe] 且 observe 绑定同一个 input
    for e in h.events:
        if e.meta.get("kind") == "noise" and e.meta.get("noise_kind") == "conflict(2)":
            if len(e.parent_ids) != 2:
                errs.append(f"NOISE parents len != 2: noise={e.id[:8]} p={len(e.parent_ids)}")
                continue

            in_id, obs_id = e.parent_ids[0], e.parent_ids[1]
            ie = by_id.get(in_id)
            oe = by_id.get(obs_id)

            if ie is None:
                errs.append(f"NOISE input parent missing: noise={e.id[:8]} in={in_id[:8]}")
            elif kind(ie) != "input":
                errs.append(f"NOISE first parent not input: noise={e.id[:8]} in={in_id[:8]} kind={kind(ie)}")

            if oe is None:
                errs.append(f"NOISE observe parent missing: noise={e.id[:8]} obs={obs_id[:8]}")
                continue
            if not (oe.meta.get("kind") == "observe" and oe.meta.get("observe") == "conflict_heat"):
                errs.append(f"NOISE second parent not conflict_heat observe: noise={e.id[:8]} obs={obs_id[:8]} kind={kind(oe)}")
                continue

            # observe 必须指向同一个 input
            if len(oe.parent_ids) != 1 or oe.parent_ids[0] != in_id:
                got = ",".join(x[:8] for x in oe.parent_ids)
                errs.append(f"PAIR mismatch: noise={e.id[:8]} expects obs.parent_ids=[{in_id[:8]}] got=[{got}]")

    if errs:
        raise AssertionError("Invariant failed: parents=conflict_pair\n- " + "\n- ".join(errs))

def frontier(h, mode="global",
             last_inputs=4, last_observes=2,
             anc_depth=6, topk=20,
             recent_k=12):
    # roots = last N inputs + last M observes
    inputs=[]; observes=[]
    for e in reversed(h.events):
        k=e.meta.get("kind")
        if k=="input" and len(inputs)<last_inputs: inputs.append(e)
        elif k=="observe" and len(observes)<last_observes: observes.append(e)
        if len(inputs)>=last_inputs and len(observes)>=last_observes: break
    roots=list(reversed(observes))+list(reversed(inputs))
    if not roots: return []

    def closure(seed_ids:Set[str]) -> Set[str]:
        keep=set()
        stack=[(sid,0) for sid in seed_ids if sid]
        while stack:
            eid,d=stack.pop()
            if eid in keep or d>anc_depth: continue
            e=h.by_id.get(eid)
            if not e: continue
            keep.add(eid)
            for pid in e.parent_ids:
                if pid: stack.append((pid,d+1))
        return keep

    if mode=="recent":
        tail_ids={e.id for e in h.events[-recent_k:]}
        root_ids={r.id for r in roots}
        seed = tail_ids | root_ids
        keep_ids = closure(seed)
        # also keep children of keep_ids (one-hop forward) so linked noise/observe stays visible
        for e in h.events:
            if any(pid in keep_ids for pid in e.parent_ids):
                keep_ids.add(e.id)
        evs=[h.by_id[i] for i in keep_ids if i in h.by_id]
    else:
        # global: build skeleton from roots, then keep edges that touch skeleton
        skel=closure({r.id for r in roots})
        keep=set(skel)
        for e in h.events:
            if any(pid in skel for pid in e.parent_ids):
                keep.add(e.id)
        evs=[h.by_id[i] for i in keep if i in h.by_id]

    evs.sort(key=lambda e: trace_score(e,h), reverse=True)
    return evs[:topk]

def print_view(title, rows, h, n=20):
    print(f"\n== View: {title} ==")
    for e in rows[:n]:
        k=e.meta.get("kind"); p=len(e.parent_ids); sc=trace_score(e,h)
        tag=f" [{e.meta.get('noise_kind','noise')}]" if k=="noise" else ""
        parents_str=""
        if p:
            parents_str=" parents=["+",".join(x[:8] for x in e.parent_ids)+"]"
        print(f"{e.ts} {e.id} {k} score={fmt_score(sc)} p={p}{parents_str}{tag} | {e.payload[:92]}{'…' if len(e.payload)>92 else ''}")

def main():
    random.seed(7)
    clk=Clock(); h=History()
    WIN=14; COOLDOWN_MS=2; TOPICS=["x","y","z"]
    last_obs_sig=None; last_conflict_ts=-10**18

    t0=random.choice(TOPICS)
    h.add(Event(clk.tick(),rnd_id(),[],{"kind":"input","topic":t0},f"evt0:{random.randint(1_000_000,9_999_999)}; topic={t0}"))

    for i in range(1,28):
        t=random.choice(TOPICS); lab=f"evt{i}:{random.randint(1_000_000,9_999_999)}"
        e=mk_input(clk,h,t,lab); h.add(e)
        if i%9==0: h.add(mk_repair(clk,h,random.choice(TOPICS)))

        heat, top, pair_ids = conflict_heat(h,WIN)
        key,_heat,dom,domc=top
        sig=sig_no_dom(WIN,heat,top)

        if sig!=last_obs_sig:
            h.add(mk_observe(clk,pair_ids,f"observe=conflict_heat; win={WIN}; total_heat={heat}; top={key}:{heat}:{dom}:{domc}"))
            last_obs_sig=sig

        if heat>=2 and (h.events[-1].ts-last_conflict_ts)>=COOLDOWN_MS:
            h.add(mk_noise(clk,pair_ids,f"NOISE:{rnd_id()}:conflict(2):top={key}:{heat}:{dom}:{domc}:{lab}; topic={t}"))
            last_conflict_ts=h.events[-1].ts

    print(f"\nHistory size: {len(h.events)} (append-only)")
    print_view("LAST_12", list(reversed(h.events))[:12], h, n=12)
    fr_recent = frontier(h, mode="recent", topk=20, recent_k=10)
    fr_global = frontier(h, mode="global", topk=20)
    print_view("FRONTIER_RECENT_K_FIXED top20 (ranked by trace_score)", fr_recent, h, n=20)
    print_view("FRONTIER_GLOBAL top20 (ranked by trace_score)", fr_global, h, n=20)

    obs=[e for e in h.events if e.meta.get("kind")=="observe"]
    obs.sort(key=lambda e: trace_score(e,h), reverse=True)
    print_view("OBSERVE_ONLY (ranked by trace_score)", obs, h, n=20)
    invariant_conflict_parents(h)
    print("\nInvariant: no deletions, no edits. Only new events.")

if __name__=="__main__":
    main()
(base) matleyentacle@MatleydeMacBook-Air spiral_core_series % python spiral_core_v046_frontier-recent-k-fix.py

History size: 66 (append-only)

== View: LAST_12 ==
1766146086766 8fe279273bec903d noise score=1.000 p=2 parents=[7fe7d9f2,7d75addb] [conflict(2)] | NOISE:ea8497bd4fbd4f7f:conflict(2):top=topic:12:z:5:evt27:2129905; topic=x
1766146086765 8435def3d5ea6b62 observe score=0.998 p=2 parents=[7fe7d9f2,7d75addb] | observe=conflict_heat; win=14; total_heat=12; top=topic:12:z:5
1766146086764 7b5280d6287c17da input score=0.996 p=1 parents=[80972588] | repair: summarize; topic=y
1766146086763 809725881626a9ff input score=0.993 p=1 parents=[1eee0660] | evt27:2129905; topic=x
1766146086762 1eee0660b7090bb2 noise score=0.991 p=2 parents=[68c85d3f,a377e659] [conflict(2)] | NOISE:7252545f1e2fe8bd:conflict(2):top=topic:11:y:6:evt26:7583025; topic=z
1766146086761 4f436ce3f8795e5c observe score=0.989 p=2 parents=[68c85d3f,a377e659] | observe=conflict_heat; win=14; total_heat=11; top=topic:11:y:6
1766146086760 7d75addb09968be7 input score=0.987 p=1 parents=[7fe7d9f2] | evt26:7583025; topic=z
1766146086759 7fe7d9f26373dd34 input score=0.985 p=1 parents=[8228143e] | evt25:1905850; topic=z
1766146086758 8228143ea02cf27f noise score=0.982 p=2 parents=[68c85d3f,a377e659] [conflict(2)] | NOISE:e31b7815c79995b6:conflict(2):top=topic:12:y:6:evt24:6345416; topic=y
1766146086757 ef0c96ed7d3a08de observe score=0.980 p=2 parents=[68c85d3f,a377e659] | observe=conflict_heat; win=14; total_heat=12; top=topic:12:y:6
1766146086756 a377e6591f9db90e input score=0.978 p=1 parents=[abeb22cd] | evt24:6345416; topic=y
1766146086755 abeb22cd3c8ca801 noise score=0.976 p=2 parents=[6aa31fda,b3183af2] [conflict(2)] | NOISE:e008017f1dadaaf5:conflict(2):top=topic:11:x:5:evt23:4059205; topic=z

== View: FRONTIER_RECENT_K_FIXED top20 (ranked by trace_score) ==
1766146086766 8fe279273bec903d noise score=1.000 p=2 parents=[7fe7d9f2,7d75addb] [conflict(2)] | NOISE:ea8497bd4fbd4f7f:conflict(2):top=topic:12:z:5:evt27:2129905; topic=x
1766146086765 8435def3d5ea6b62 observe score=0.998 p=2 parents=[7fe7d9f2,7d75addb] | observe=conflict_heat; win=14; total_heat=12; top=topic:12:z:5
1766146086764 7b5280d6287c17da input score=0.996 p=1 parents=[80972588] | repair: summarize; topic=y
1766146086763 809725881626a9ff input score=0.993 p=1 parents=[1eee0660] | evt27:2129905; topic=x
1766146086762 1eee0660b7090bb2 noise score=0.991 p=2 parents=[68c85d3f,a377e659] [conflict(2)] | NOISE:7252545f1e2fe8bd:conflict(2):top=topic:11:y:6:evt26:7583025; topic=z
1766146086761 4f436ce3f8795e5c observe score=0.989 p=2 parents=[68c85d3f,a377e659] | observe=conflict_heat; win=14; total_heat=11; top=topic:11:y:6
1766146086760 7d75addb09968be7 input score=0.987 p=1 parents=[7fe7d9f2] | evt26:7583025; topic=z
1766146086759 7fe7d9f26373dd34 input score=0.985 p=1 parents=[8228143e] | evt25:1905850; topic=z
1766146086758 8228143ea02cf27f noise score=0.982 p=2 parents=[68c85d3f,a377e659] [conflict(2)] | NOISE:e31b7815c79995b6:conflict(2):top=topic:12:y:6:evt24:6345416; topic=y
1766146086757 ef0c96ed7d3a08de observe score=0.980 p=2 parents=[68c85d3f,a377e659] | observe=conflict_heat; win=14; total_heat=12; top=topic:12:y:6
1766146086756 a377e6591f9db90e input score=0.978 p=1 parents=[abeb22cd] | evt24:6345416; topic=y
1766146086755 abeb22cd3c8ca801 noise score=0.976 p=2 parents=[6aa31fda,b3183af2] [conflict(2)] | NOISE:e008017f1dadaaf5:conflict(2):top=topic:11:x:5:evt23:4059205; topic=z
1766146086754 b30a3da171e824c2 input score=0.974 p=1 parents=[b3183af2] | evt23:4059205; topic=z
1766146086753 b3183af2b13c2874 input score=0.972 p=1 parents=[331ec0bc] | evt22:1202384; topic=x
1766146086752 331ec0bc6fe8b3ce noise score=0.969 p=2 parents=[3a9f2b6e,6aa31fda] [conflict(2)] | NOISE:a79f403a181ff53a:conflict(2):top=topic:11:x:5:evt21:7382745; topic=y
1766146086751 9bd4603234a1884c observe score=0.967 p=2 parents=[3a9f2b6e,6aa31fda] | observe=conflict_heat; win=14; total_heat=11; top=topic:11:x:5
1766146086750 68c85d3f5c9262ad input score=0.965 p=1 parents=[903b5fae] | evt21:7382745; topic=y
1766146086749 903b5fae4c829a16 input score=0.963 p=1 parents=[52e8ba7e] | evt20:5671130; topic=z
1766146086748 52e8ba7ed8a59510 noise score=0.961 p=2 parents=[9071b5b0,d4785f3b] [conflict(2)] | NOISE:dd55707e2bfbf0d1:conflict(2):top=topic:11:y:5:evt19:3791163; topic=x
1766146086746 6aa31fdaa9e003d8 input score=0.957 p=1 parents=[4a7a489e] | evt19:3791163; topic=x

== View: FRONTIER_GLOBAL top20 (ranked by trace_score) ==
1766146086766 8fe279273bec903d noise score=1.000 p=2 parents=[7fe7d9f2,7d75addb] [conflict(2)] | NOISE:ea8497bd4fbd4f7f:conflict(2):top=topic:12:z:5:evt27:2129905; topic=x
1766146086765 8435def3d5ea6b62 observe score=0.998 p=2 parents=[7fe7d9f2,7d75addb] | observe=conflict_heat; win=14; total_heat=12; top=topic:12:z:5
1766146086764 7b5280d6287c17da input score=0.996 p=1 parents=[80972588] | repair: summarize; topic=y
1766146086763 809725881626a9ff input score=0.993 p=1 parents=[1eee0660] | evt27:2129905; topic=x
1766146086762 1eee0660b7090bb2 noise score=0.991 p=2 parents=[68c85d3f,a377e659] [conflict(2)] | NOISE:7252545f1e2fe8bd:conflict(2):top=topic:11:y:6:evt26:7583025; topic=z
1766146086761 4f436ce3f8795e5c observe score=0.989 p=2 parents=[68c85d3f,a377e659] | observe=conflict_heat; win=14; total_heat=11; top=topic:11:y:6
1766146086760 7d75addb09968be7 input score=0.987 p=1 parents=[7fe7d9f2] | evt26:7583025; topic=z
1766146086759 7fe7d9f26373dd34 input score=0.985 p=1 parents=[8228143e] | evt25:1905850; topic=z
1766146086758 8228143ea02cf27f noise score=0.982 p=2 parents=[68c85d3f,a377e659] [conflict(2)] | NOISE:e31b7815c79995b6:conflict(2):top=topic:12:y:6:evt24:6345416; topic=y
1766146086757 ef0c96ed7d3a08de observe score=0.980 p=2 parents=[68c85d3f,a377e659] | observe=conflict_heat; win=14; total_heat=12; top=topic:12:y:6
1766146086756 a377e6591f9db90e input score=0.978 p=1 parents=[abeb22cd] | evt24:6345416; topic=y
1766146086755 abeb22cd3c8ca801 noise score=0.976 p=2 parents=[6aa31fda,b3183af2] [conflict(2)] | NOISE:e008017f1dadaaf5:conflict(2):top=topic:11:x:5:evt23:4059205; topic=z
1766146086754 b30a3da171e824c2 input score=0.974 p=1 parents=[b3183af2] | evt23:4059205; topic=z
1766146086753 b3183af2b13c2874 input score=0.972 p=1 parents=[331ec0bc] | evt22:1202384; topic=x
1766146086752 331ec0bc6fe8b3ce noise score=0.969 p=2 parents=[3a9f2b6e,6aa31fda] [conflict(2)] | NOISE:a79f403a181ff53a:conflict(2):top=topic:11:x:5:evt21:7382745; topic=y
1766146086751 9bd4603234a1884c observe score=0.967 p=2 parents=[3a9f2b6e,6aa31fda] | observe=conflict_heat; win=14; total_heat=11; top=topic:11:x:5
1766146086750 68c85d3f5c9262ad input score=0.965 p=1 parents=[903b5fae] | evt21:7382745; topic=y
1766146086749 903b5fae4c829a16 input score=0.963 p=1 parents=[52e8ba7e] | evt20:5671130; topic=z
1766146086748 52e8ba7ed8a59510 noise score=0.961 p=2 parents=[9071b5b0,d4785f3b] [conflict(2)] | NOISE:dd55707e2bfbf0d1:conflict(2):top=topic:11:y:5:evt19:3791163; topic=x
1766146086747 7e4b7d731f622590 observe score=0.959 p=2 parents=[9071b5b0,d4785f3b] | observe=conflict_heat; win=14; total_heat=11; top=topic:11:y:5

== View: OBSERVE_ONLY (ranked by trace_score) ==
1766146086765 8435def3d5ea6b62 observe score=0.998 p=2 parents=[7fe7d9f2,7d75addb] | observe=conflict_heat; win=14; total_heat=12; top=topic:12:z:5
1766146086761 4f436ce3f8795e5c observe score=0.989 p=2 parents=[68c85d3f,a377e659] | observe=conflict_heat; win=14; total_heat=11; top=topic:11:y:6
1766146086757 ef0c96ed7d3a08de observe score=0.980 p=2 parents=[68c85d3f,a377e659] | observe=conflict_heat; win=14; total_heat=12; top=topic:12:y:6
1766146086751 9bd4603234a1884c observe score=0.967 p=2 parents=[3a9f2b6e,6aa31fda] | observe=conflict_heat; win=14; total_heat=11; top=topic:11:x:5
1766146086747 7e4b7d731f622590 observe score=0.959 p=2 parents=[9071b5b0,d4785f3b] | observe=conflict_heat; win=14; total_heat=11; top=topic:11:y:5
1766146086744 a4924d657c1a760f observe score=0.952 p=2 parents=[55ba4ba3,0d70d60b] | observe=conflict_heat; win=14; total_heat=10; top=topic:10:z:5
1766146086737 8d7a39d75970d289 observe score=0.938 p=2 parents=[b495b0d4,55ba4ba3] | observe=conflict_heat; win=14; total_heat=9; top=topic:9:z:6
1766146086730 22436ffc39d4cf1b observe score=0.923 p=2 parents=[c26afcbb,b495b0d4] | observe=conflict_heat; win=14; total_heat=10; top=topic:10:z:6
1766146086727 4220a6efdb958bcc observe score=0.917 p=2 parents=[c26afcbb,b495b0d4] | observe=conflict_heat; win=14; total_heat=9; top=topic:9:z:6
1766146086724 8264cb8addaea5a0 observe score=0.911 p=2 parents=[54c39dbd,c26afcbb] | observe=conflict_heat; win=14; total_heat=8; top=topic:8:z:5
1766146086717 48013605aaab289d observe score=0.897 p=2 parents=[53f2040e,38d3ba15] | observe=conflict_heat; win=14; total_heat=6; top=topic:6:z:3
1766146086714 2866c7a2015f8094 observe score=0.891 p=2 parents=[b0fd68e2,4aa32576] | observe=conflict_heat; win=14; total_heat=5; top=topic:5:y:2
1766146086711 4a91a428035f7d2b observe score=0.885 p=2 parents=[b0fd68e2,4aa32576] | observe=conflict_heat; win=14; total_heat=4; top=topic:4:y:2
1766146086708 b28c89bdfebce525 observe score=0.879 p=2 parents=[b0fd68e2,4aa32576] | observe=conflict_heat; win=14; total_heat=3; top=topic:3:y:2
1766146086705 693690b139dc012f observe score=0.873 p=2 parents=[b0fd68e2,4aa32576] | observe=conflict_heat; win=14; total_heat=2; top=topic:2:y:2
1766146086703 d3760046af57c43e observe score=0.869 p=2 parents=[b0fd68e2,add7d9c6] | observe=conflict_heat; win=14; total_heat=1; top=topic:1:y:1

Invariant: no deletions, no edits. Only new events.
(base) matleyentacle@MatleydeMacBook-Air spiral_core_series % 
可以加一条 强绑定规则.本次開發結束了嗎？
總結一下從第一版到現在都幹了啥。
總結性寫一篇完整的放入spiral_core_series的包裡

## A-Mode Frontier (Trace-Closure) — Formal Definition

---

## 1. 基本集合与结构

### 1.1 事件集合

设事件全集为  
[  
\mathcal{E} = { e_0, e_1, \dots }  
]

每个事件定义为五元组：  
[  
e = (id_e,; t_e,; k_e,; P_e,; s_e)  
]

其中：

- ( id_e \in \mathcal{H} )（哈希空间）
    
- ( t_e \in \mathbb{R} )（时间戳）
    
- ( k_e \in {\text{input}, \text{observe}, \text{noise}, \text{repair}} )
    
- ( P_e \subseteq \mathcal{H} )（父事件 ID 集）
    
- ( s_e \in \mathbb{R}^{+} )（trace score）
    

---

### 1.2 历史序列（Append-Only）

历史是一个严格追加的序列：  
[  
\mathcal{H} = (e_0 \prec e_1 \prec \dots \prec e_n)  
]

不变式：  
[  
\forall i < j,\quad t_{e_i} \le t_{e_j}  
]

且不存在删除或修改操作。

---

## 2. 因果图（Causal DAG）

定义有向图：  
[  
G = (\mathcal{E}, \rightarrow)  
]

其中：  
[  
p \rightarrow e \iff id_p \in P_e  
]

约束：  
[  
G \text{ is a DAG}  
]

---

## 3. Trace Score（排序权重）

定义函数：  
[  
\text{trace_score} : \mathcal{E} \rightarrow \mathbb{R}^{+}  
]

语义约束：

- 不影响事件生成
    
- 不影响因果关系
    
- **仅用于视图排序**
    

---

## 4. Seed（时间种子）

定义最近 (K) 个事件集合：  
[  
\text{Seed}_K = { e_{n-K+1}, \dots, e_n }  
]

---

## 5. 因果闭包算子（Trace-Closure）

定义闭包算子：  
[  
\mathcal{C} : 2^{\mathcal{E}} \rightarrow 2^{\mathcal{E}}  
]

### 5.1 向上闭包（Causal Ancestry）

[  
\forall e \in S,; \forall p \in \mathcal{E},;  
(p \rightarrow e) \Rightarrow p \in \mathcal{C}(S)  
]

递归应用，直到满足：

- 无新父节点，或
    
- 父深度 ( \le D )
    

---

### 5.2 向下闭包（Reactive Explanation）

[  
\forall p \in S,; \forall e \in \mathcal{E},  
]

若：  
[  
(p \rightarrow e) \land (k_e \in {\text{observe}, \text{noise}, \text{repair}})  
]

则：  
[  
e \in \mathcal{C}(S)  
]

---

### 5.3 闭包不动点

[  
\mathcal{C}^*(S) = \min { T \mid S \subseteq T \land \mathcal{C}(T) = T }  
]

---

## 6. A-Mode Frontier（RECENT_A）

### 6.1 集合定义

[  
\text{RECENT}_A(K) = \mathcal{C}^*(\text{Seed}_K)  
]

---

### 6.2 排序视图

RECENT_A 的输出顺序为：  
[  
\text{sort}_{\downarrow}  
\big(  
\text{RECENT}_A,  
; (s_e,; t_e)  
\big)  
]

---

## 7. 语义保证（Formal Properties）

### P1. 因果完备性（Causal Closure）

[  
\forall e \in \text{RECENT}_A,;  
\forall p,; (p \rightarrow e) \Rightarrow p \in \text{RECENT}_A  
]

---

### P2. 最近解释性（Recent Explainability）

[  
\forall e \in \text{RECENT}_A,;  
\exists r \in \text{Seed}_K  
\text{ such that }  
(e \leadsto r \lor r \leadsto e)  
]

其中 ( \leadsto ) 表示因果路径。

---

### P3. 重要性解耦（Score Orthogonality）

[  
e \in \text{RECENT}_A  
;;\not\Rightarrow;;  
s_e \text{ is maximal}  
]

---

## 8. 对比性定理（非形式但可引用）

> **RECENT_A 是时间种子在因果图上的最小闭合扩展。**

---

## 9. 可直接引用的论文句（Formal English）

> _Let RECENT_A be defined as the minimal causally closed subgraph generated from the last (K) events, incorporating both ancestral causes and reactive system responses._

---

# 1.2 Non-Equivalence Proof: RECENT_A vs Sliding Window

## 1.2.1 定义

设事件日志为按时间严格递增序列  
[  
\mathcal{H} = \langle e_0, e_1, \dots, e_{N-1}\rangle  
]  
每个事件 (e_i) 具有时间戳 (t_i) 且 (t_i < t_{i+1})。

### Sliding Window（SW_K）

取最后 (K) 个事件：  
[  
SW_K(\mathcal{H}) = {e_{N-K}, \dots, e_{N-1}}  
]

### RECENT_A（R_A）

先取 Seed：  
[  
Seed_K(\mathcal{H}) = SW_K(\mathcal{H})  
]  
然后做因果闭包（包含向上 ancestry + 向下 reactive expansion）：  
[  
R_A(\mathcal{H}) = Closure(Seed_K(\mathcal{H}))  
]  
其中 Closure 满足：

- **(Up)** 若 (x \in R_A) 且 (p) 是 (x) 的 parent，则 (p \in R_A)（在深度 cutoff 内）
    
- **(Down)** 若 (x \in R_A) 且存在绑定到 (x) 的 observe/noise/repair 后继 (y)，则 (y \in R_A)
    

---

## 1.2.2 命题

> **命题 1（不等价）**：对任意固定 (K\ge 1)，存在某个历史 (\mathcal{H})，使得  
> [  
> R_A(\mathcal{H}) \neq SW_K(\mathcal{H})  
> ]

---

## 1.2.3 构造性反例（最小反例）

取 (K=1)（一般 (K) 同理）。

构造 3 个事件：

1. (e_0)：输入事件（input）
    
2. (e_1)：输入事件（input），并声明 parent 指向 (e_0)  
    [  
    parent(e_1)={e_0}  
    ]
    
3. (e_2)：最新事件（input），与 (e_1) 冲突，触发 observe 绑定到冲突输入（你 v0.37+ 的规则）  
    于是存在观察事件 (o_2)，满足：  
    [  
    parent(o_2)={e_1,e_2}  
    ]  
    （observe/noise/repair 在日志里都是事件节点。）
    

此时日志末尾为 (o_2) 或 (e_2)（不影响结论；我们以 (e_2) 为最后一个 input 也可）。

---

## 1.2.4 计算两者

### Sliding Window（(K=1)）

[  
SW_1(\mathcal{H}) = {e_2}  
]

### RECENT_A

Seed 为 ({e_2})。

由于冲突触发的 observe 绑定到冲突输入集合，并且 Closure 的 **Down** 规则会把这些绑定后继纳入：

- (e_2 \in R_A)
    
- observe (o_2) 绑定 (e_2)（以及 (e_1)），所以 (o_2 \in R_A)
    
- 由于 (o_2) 的 parents 含 (e_1)，按 **Up** 规则，(e_1 \in R_A)
    
- 因为 (e_1) parent 指向 (e_0)，按 **Up** 规则，(e_0 \in R_A)
    

因此：  
[  
R_A(\mathcal{H}) \supseteq {e_2, o_2, e_1, e_0}  
]

显然：  
[  
R_A(\mathcal{H}) \neq SW_1(\mathcal{H})  
]

命题得证。□

---

## 1.2.5 推论：不存在“仅调 K”即可等价的映射

> **推论 1**：不存在一个函数 (f)，使得对所有历史 (\mathcal{H})：  
> [  
> R_A(\mathcal{H}) = SW_{f(K)}(\mathcal{H})  
> ]

理由很直观：  
Sliding Window 只能“向后截断”，无法根据因果边把更早的祖先事件重新拉回；而 (R_A) 的 Closure 允许“时间回溯”与“语义回溯”，因此两者的选择准则是不同的范畴（time-based vs causal-based）。

---

## 1.2.6 你这套系统里的“更强”版本结论

在 Spiral 的 append-only + observe/noise 绑定规则下：

- **只要存在任何跨窗口的 parent 边**，RECENT_A 就可能包含窗口外事件；
    
- **只要存在冲突绑定事件**（observe/noise/repair 作为后继），RECENT_A 就可能包含窗口外的解释链。
    

因此 RECENT_A 的语义是：

> “最后 K 个事件的因果解释闭包”，而不是“最后 K 个事件本身”。

---
## 1.2.7 工程可引用反例（按你的日志事件格式）

下面给一个**最小可复现**的“RECENT_A ≠ SlidingWindow(K)”反例，用你现在这套 **append-only + observe parents 绑定冲突输入 + noise cooldown** 的语义来写。

---

### 事件序列（History）

设 K=2（你用 K=10/20 也一样能构造）。

我们构造 6 条事件（时间递增）：


t1  A  input   | evt10:AAAAAAA; topic=x
t2  B  input   | evt11:BBBBBBB; topic=x

t3  C  input   | evt12:CCCCCCC; topic=y      # 和 x 形成竞争态（比如 heat/top 更新）
t4  O  observe | observe=conflict_heat; top=topic:1:x:2
               # v0.37+ 规则：observe 的 parents 绑定冲突输入集合
               # parents(O) = {A, C}   (或 {B, C}，看你的冲突选择策略)

t5  R  repair  | repair: summarize; topic=x
               # 典型实现：repair parents(O) 或 parents(top input)
               # parents(R) = {O}  (或 {O, A})

t6  N  noise   | NOISE:...:conflict(2):top=topic:1:x:2:evt10...
               # noise cooldown=2：只在满足冷却条件时 emit
               # parents(N) = {O, C} 或 {O}（取决于你实现）


关键点只有一个：**observe O 的 parents 必须显式包含“导致冲突的输入”**（v0.37 的核心改动），以及后续 repair/noise 对 O 有绑定（常见）。

---

### Sliding Window 结果（SW_K）

取最后 K=2 个事件：


SW_2 = { R, N }   (如果最后两条是 t5,t6)


它**绝不会**包含 A/B/C/O，因为它只看时间尾部截断。

---

### RECENT_A 结果（R_A）

RECENT_A 的语义是：

1. 先取 seed：最后 K 条（同 SW）
    
2. 再做 Closure：把 seed 的 parents、parents 的 parents…拉进来（Up），同时把 seed 绑定的解释后继也纳入（Down / reactive expansion）
    

所以从 R 和 N 开始：

- R ∈ R_A，且 parents(R) = {O} ⇒ O ∈ R_A
    
- N ∈ R_A，且 parents(N) 含 {O} 或 {O,C} ⇒ O ∈ R_A（且可能 C ∈ R_A）
    
- O ∈ R_A，且 **parents(O) = {A,C}**（冲突输入绑定） ⇒ A ∈ R_A 且 C ∈ R_A
    
- 如果 A 还引用更早祖先（例如 topic x 的前序输入 B），则继续被拉进来（取决于你的 parent depth cutoff）
    

因此一个典型结果：


R_A ⊇ { R, N, O, A, C }   （甚至可能包含 B）


---

### 结论（工程语句）

- SW_2 = {R, N}
    
- R_A ⊇ {R, N, O, A, C}
    

所以：

> **RECENT_A 必然可以包含窗口外事件（A/C/O），而 SlidingWindow 永远不能。**  
> 因此两者不可能等价；调 K 也无法补齐，因为缺的是“因果回溯能力”，不是“窗口长度”。

---

反例日誌：
History size: 6 (append-only)

== View: LAST_6 ==
1766145000001 aaaaaaaa11111111 input  score=6.393e-02 p=1  | evt10:AAAAAAA; topic=x
1766145000002 bbbbbbbb22222222 input  score=3.688e-02 p=1  | evt11:BBBBBBB; topic=y
1766145000003 cccccccc33333333 input  score=2.128e-02 p=1  | evt12:CCCCCCC; topic=x

1766145000004 oooooooo44444444 observe score=1.228e-02 p=4  | observe=conflict_heat; win=14; total_heat=2; top=topic:2:x:2
                 parents=[aaaaaaaa11111111, bbbbbbbb22222222]
                 note=observe parents bind conflict inputs (x vs y)

1766145000005 rrrrrrrr55555555 input  score=7.083e-03 p=1  | repair: summarize; topic=x
                 parents=[oooooooo44444444]

1766145000006 nnnnnnnn66666666 noise score=4.087e-03 p=2 [conflict(2)] | NOISE:deadbeefcafebabe:conflict(2):top=topic:2:x:2:evt10:AAAAAAA; topic=y
                 parents=[oooooooo44444444]
                 cooldown=2
这个反例里，两种“最近集”输出会长这样
1) SlidingWindow(K=2)
只取最后两条：

text
复制代码
SW_2 = {
  rrrrrrrr55555555  (repair)
  nnnnnnnn66666666  (noise)
}
2) RECENT_A(K=2)
从 seed={repair, noise} 开始做 parents 闭包：

repair → parent = observe

noise → parent = observe

observe → parents = {input(evt10 x), input(evt11 y)} （关键：绑定冲突输入）

所以：

text
复制代码
RECENT_A(K=2) = {
  rrrrrrrr55555555  (repair)
  nnnnnnnn66666666  (noise)
  oooooooo44444444  (observe)
  aaaaaaaa11111111  (input evt10 x)
  bbbbbbbb22222222  (input evt11 y)
}
 能整理一下嗎